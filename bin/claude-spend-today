#!/usr/bin/env bash
set -euo pipefail

PROJECTS_DIR="${HOME}/.claude/projects"
TODAY=$(date +%Y-%m-%d)
CACHE_DIR="${HOME}/.claude/powerline/usage"
CACHE_FILE="${CACHE_DIR}/tmux-today.txt"
CACHE_TTL=60

# Check if cache is valid and return cached value
check_cache() {
  [[ ! -f "$CACHE_FILE" ]] && return 1

  local cache_mtime now
  # macOS: date -r file +%s, Linux: stat -c %Y file
  cache_mtime=$(date -r "$CACHE_FILE" +%s 2> /dev/null || stat -c %Y "$CACHE_FILE" 2> /dev/null) || return 1
  now=$(date +%s)

  if ((now - cache_mtime < CACHE_TTL)); then
    cat "$CACHE_FILE"
    return 0
  fi
  return 1
}

# Save result to cache
save_cache() {
  mkdir -p "$CACHE_DIR"
  echo "$1" > "$CACHE_FILE"
}

# Check cache first
if cached=$(check_cache); then
  echo "$cached"
  exit 0
fi

if [[ ! -d "$PROJECTS_DIR" ]]; then
  echo "\$0.00"
  exit 0
fi

# Extract usage with model info and calculate cost per model family
# AWS Bedrock pricing per million tokens (US regions)
result=$(find "$PROJECTS_DIR" -name "*.jsonl" -mtime -2 -print0 2> /dev/null \
  | xargs -0 grep -h "\"timestamp\":\"${TODAY}" 2> /dev/null \
  | grep '"usage":' \
  | jq -s '
        # Pricing per million tokens by model family
        def pricing:
            {
                opus:   {input: 15,   output: 75, cache_create: 18.75, cache_read: 1.5},
                sonnet: {input: 3,    output: 15, cache_create: 3.75,  cache_read: 0.3},
                haiku:  {input: 1,    output: 5,  cache_create: 1.25,  cache_read: 0.1}
            };

        # Detect model family from model string
        def model_family:
            if . == null then "opus"
            elif test("opus"; "i") then "opus"
            elif test("sonnet"; "i") then "sonnet"
            elif test("haiku"; "i") then "haiku"
            else "opus"
            end;

        # Calculate cost for a single entry
        def entry_cost:
            (.message.model | model_family) as $family |
            pricing[$family] as $price |
            (.message.usage // {}) as $usage |
            (
                (($usage.input_tokens // 0) * $price.input / 1000000) +
                (($usage.output_tokens // 0) * $price.output / 1000000) +
                (($usage.cache_creation_input_tokens // 0) * $price.cache_create / 1000000) +
                (($usage.cache_read_input_tokens // 0) * $price.cache_read / 1000000)
            );

        # Sum tokens by type
        def sum_tokens:
            {
                input: (map(.message.usage.input_tokens // 0) | add // 0),
                output: (map(.message.usage.output_tokens // 0) | add // 0),
                cache_create: (map(.message.usage.cache_creation_input_tokens // 0) | add // 0),
                cache_read: (map(.message.usage.cache_read_input_tokens // 0) | add // 0)
            } |
            . + {total: (.input + .output + .cache_create + .cache_read)};

        {
            tokens: sum_tokens,
            cost: (map(entry_cost) | add // 0)
        }
    ')

cost=$(echo "$result" | jq -r '.cost')
tokens=$(echo "$result" | jq -r '.tokens.total')

# Format output
if (($(echo "$cost < 0.01" | bc -l))); then
  formatted="<\$0.01"
else
  formatted=$(printf "\$%.2f" "$cost")
fi

# Save to cache and output
save_cache "$formatted"
echo "$formatted"
